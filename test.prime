(define cadr   (λ (xs) (car (cdr xs))))
(define cddr   (λ (xs) (cdr (cdr xs))))
(define caddr  (λ (xs) (car (cdr (cdr xs)))))
(define cdddr  (λ (xs) (car (cdr (cdr xs)))))
(define cadddr (λ (xs) (car (cdr (cdr (cdr xs))))))
(define cddddr (λ (xs) (cdr (cdr (cdr (cdr xs))))))

(define defun    (macro σ (list 'define (car σ) (cons 'λ (cons (cadr σ) (cddr σ))))))
(define defmacro (macro σ (list 'define (car σ) (cons 'macro  (cons (cadr σ) (cddr σ))))))

(defun idfun (x) x)
(defun const (x y) x)

(defun odd-elements  (xs) (if (= xs nil) nil (cons (car xs)  (odd-elements  (cddr xs)))))
(defun even-elements (xs) (if (= xs nil) nil (cons (cadr xs) (even-elements (cddr xs)))))

(defun semiquote/eager (ε)
  (if (= (typeof ε) 'list)
      (if (= (car ε) 'unquote)
          (if (= (length ε) 2) (cadr ε) (fail "unquote"))
          (cons 'list (mapcar semiquote/eager ε)))
      (list 'quote ε)))

(defmacro semiquote σ (semiquote/eager σ))

(defmacro let σ
  (cons (cons 'λ (cons (odd-elements (car σ)) (cdr σ)))
        (even-elements (car σ))))

(defmacro defthm (name statement proof)
  (list 'progn (list 'define name proof)
    (list 'if (list '= (list 'formula name) statement)
      nil (list 'fail "defthm:" (list 'formula name) "≠" statement))))

(defmacro DICT σ (list 'dict (cons 'list σ)))
(defmacro SET  σ (list 'set  (cons 'list σ)))

;;;;

(define ⊥ (app "false" nil))

(defun impl (P Q) (app "Impl" (list P Q)))

(defun ¬ (P) (impl P ⊥))
(defun ¬¬ (P) (¬ (¬ P)))

(define ⊤ (¬ ⊥))

(defun proj (τ n) (nth n (cdr τ)))
(defun arity (τ) (length (cdr τ)))

(deftheory ZOL ;; zeroth-order logic
  (defmacro well-formed? σ
    (list 'if (cons 'and (mapcar (λ (ε) (list '= (list 'theory ε) "ZOL")) σ)) nil
      (list 'fail "expected formula of zeroth-order logic")))

  (defun invariance₁ (θ T)   (well-formed? T) (postulate (subst θ (formula T))))
  (defun invariance₂ (x y T) (well-formed? T) (postulate (interchange x y (formula T))))

  (defun mp (T₁ T₂) (well-formed? T₁ T₂)
    (case (formula T₁) (var "P")
          (formula T₂) (impl (var "P") (var "Q"))
      (postulate Q)))

  (defun veq (α β) (postulate (impl α (impl β α))))

  (defun cr (α β γ) (postulate (impl (impl α (impl β γ))
                                     (impl (impl α β) (impl α γ)))))

  (defun ¬¬-elim (α) (postulate (impl (¬¬ α) α))))

;; Γ ⊢ Q ⊃ Γ ⊢ P → Q
(defun →-intro (P T) (mp T (veq (formula T) P)))

(defthm principle-of-explosion (impl ⊥ (var "P"))
  (mp (veq ⊥ (¬ (var "P")))
      (mp (→-intro ⊥ (¬¬-elim (var "P")))
          (cr ⊥ (¬¬ (var "P")) (var "P")))))

(defthm I (impl (var "α") (var "α"))
  (mp (veq (var "α") (var "α"))
      (mp (veq (var "α") (impl (var "α") (var "α")))
          (cr (var "α") (impl (var "α") (var "α")) (var "α")))))

;; Γ ⊢ P → Q ⊃ Γ ⊢ P → (P → Q)
(defun dup (T) (→-intro (proj (formula T) 0) T))

;; Γ ⊢ P → (P → Q) ⊃ Γ ⊢ P → Q
(defun pop (T)
  (case (formula T) (impl (var "P") (impl (var "P") (var "Q")))
    (mp (invariance₁ (DICT "α" P) I) (mp T (cr P P Q)))))

(defthm cut (impl (var "P") (impl (impl (var "P") (var "Q")) (var "Q")))
  (let (T₁ (→-intro (var "P")
             (mp (invariance₁ (DICT "α" (impl (var "P") (var "Q"))) I)
                 (cr (impl (var "P") (var "Q")) (var "P") (var "Q"))))
        T₂ (cr (var "P")
               (impl (impl (var "P") (var "Q")) (var "P"))
               (impl (impl (var "P") (var "Q")) (var "Q")))
        T₃ (veq (var "P") (impl (var "P") (var "Q"))))
    (mp T₃ (mp T₁ T₂))))

(defthm ¬¬-intro (impl (var "α") (¬¬ (var "α")))
  (invariance₁ (DICT "P" (var "α") "Q" ⊥) cut))

(defthm →-comm (impl (impl (var "P") (impl (var "Q") (var "R")))
                     (impl (var "Q") (impl (var "P") (var "R"))))
  (let (T₁ (mp (invariance₁ (DICT "P" (var "Q") "Q" (var "R")) cut)
               (mp (→-intro (var "Q") (veq (impl (impl (var "Q") (var "R")) (var "R")) (var "P")))
                   (cr (var "Q")
                       (impl (impl (var "Q") (var "R")) (var "R"))
                       (impl (var "P") (impl (impl (var "Q") (var "R")) (var "R"))))))
        T₂ (→-intro (var "Q") (cr (var "P")
                                  (impl (var "Q") (var "R"))
                                  (var "R")))
        T₃ (cr (var "Q")
               (impl (var "P") (impl (impl (var "Q") (var "R")) (var "R")))
               (impl (impl (var "P") (impl (var "Q") (var "R"))) (impl (var "P") (var "R"))))
        T₄ (cr (var "Q")
               (impl (var "P") (impl (var "Q") (var "R")))
               (impl (var "P") (var "R")))
        T₅ (cr (impl (var "P") (impl (var "Q") (var "R")))
               (impl (var "Q") (impl (var "P") (impl (var "Q") (var "R"))))
               (impl (var "Q") (impl (var "P") (var "R"))))
        T₆ (veq (impl (var "P") (impl (var "Q") (var "R")))
                (var "Q")))
    (mp T₆ (mp (→-intro (impl (var "P") (impl (var "Q") (var "R"))) (mp (mp T₁ (mp T₂ T₃)) T₄)) T₅))))

;; https://en.wikipedia.org/wiki/Hypothetical_syllogism#Proof
(defthm hypsyll (impl (impl (var "Q") (var "R"))
                      (impl (impl (var "P") (var "Q"))
                            (impl (var "P") (var "R"))))
  (let (T₁ (mp (cr (var "P") (var "Q") (var "R"))
               (veq (impl (impl (var "P") (impl (var "Q") (var "R")))
                                 (impl (impl (var "P") (var "Q"))
                                       (impl (var "P") (var "R"))))
                    (impl (var "Q") (var "R"))))
        T₂ (cr (impl (var "Q") (var "R"))
               (impl (var "P") (impl (var "Q") (var "R")))
               (impl (impl (var "P") (var "Q"))
                     (impl (var "P") (var "R"))))
        T₃ (veq (impl (var "Q") (var "R")) (var "P")))
    (mp T₃ (mp T₁ T₂))))

;;;;

(defthm test-thm (impl (var "B") (var "B"))
  (invariance₂ "α" "B" I))

(define ∃ (λ (x P) (binder "∃" x P)))

(define τ₀ (∃ "y" (app "Ineq" (list (var "x") (var "y")))))
;(print (subst (DICT "x" (var "y")) τ₀) "\n") ; will emit an error
(print (subst (DICT "x" (var "z")) τ₀) "\n")

(let (Φ (veq (var "A") (var "B")))
  (print Φ " & " (formula Φ) "\n"))

(print (invariance₁ (DICT "α" (var "A")) I) "\n")
(print ¬¬-elim "\n")

(let (x 1 y 2) (print (+ x y)) (newline))

(defmacro incr! (x) (semiquote assign! (unquote x) (+ (deref (unquote x)) 1)))

(let (n (ref 0))
  (loop (print (deref n) " ") (incr! n)
        (not (= (deref n) 5))))
(newline)

(define generate-macro (λ (name) (macro (y) (list '+ name y))))

(print "fin")
(newline)