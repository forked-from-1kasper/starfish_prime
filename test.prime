(define cadr   (λ (xs) (car (cdr xs))))
(define cddr   (λ (xs) (cdr (cdr xs))))
(define caddr  (λ (xs) (car (cdr (cdr xs)))))
(define cdddr  (λ (xs) (car (cdr (cdr xs)))))
(define cadddr (λ (xs) (car (cdr (cdr (cdr xs))))))
(define cddddr (λ (xs) (cdr (cdr (cdr (cdr xs))))))

(define defun    (macro σ (list 'define (car σ) (cons 'λ (cons (cadr σ) (cddr σ))))))
(define defmacro (macro σ (list 'define (car σ) (cons 'macro  (cons (cadr σ) (cddr σ))))))

(defun idfun (x) x)
(defun const (x y) x)

(defun odd-elements  (xs) (if (= xs nil) nil (cons (car xs)  (odd-elements  (cddr xs)))))
(defun even-elements (xs) (if (= xs nil) nil (cons (cadr xs) (even-elements (cddr xs)))))

;(defun mapcar (φ xs) (if (= xs nil) nil (cons (φ (car xs)) (mapcar φ (cdr xs)))))

(defun semiquote/eager (ε)
  (if (= (typeof ε) 'list)
      (if (= (car ε) 'unquote)
          (if (= (length ε) 2) (cadr ε) (fail "unquote"))
          (cons 'list (mapcar semiquote/eager ε)))
      (list 'quote ε)))

(defmacro semiquote σ (semiquote/eager σ))

(defmacro let σ
  (cons (cons 'λ (cons (odd-elements (car σ)) (cdr σ)))
        (even-elements (car σ))))

(defmacro defthm (name statement proof)
  (list 'progn (list 'define name proof)
    (list 'if (list '= (list 'formula name) statement)
      nil (list 'fail "defthm:" (list 'formula name) "≠" statement))))

;;;;

(define ⊥ (app "false" nil))

(defun impl (P Q) (app "Impl" (list P Q)))

(defun ¬ (P) (impl P ⊥))
(defun ¬¬ (P) (¬ (¬ P)))

(define ⊤ (¬ ⊥))

(defun proj (τ n) (nth n (cdr τ)))
(defun arity (τ) (length (cdr τ)))

(deftheory ZOL ;; zeroth-order logic
  (defmacro well-founded? σ
    (list 'if (cons 'and (mapcar (λ (ε) (list '= (list 'theory ε) "ZOL")) σ)) nil
      (list 'fail "expected formula of zeroth-order logic")))

  (defun invariance₁ (θ T)   (well-founded? T) (postulate (subst θ (formula T))))
  (defun invariance₂ (x y T) (well-founded? T) (postulate (interchange x y (formula T))))

  (defun mp (T₁ T₂) (well-founded? T₁ T₂)
    (case (formula T₁) (var "P")
          (formula T₂) (impl (var "P") (var "Q"))
      (postulate Q)))

  (define veq (postulate (impl (var "α") (impl (var "β") (var "α")))))

  (define cr (postulate (impl (impl (var "α") (impl (var "β") (var "γ")))
                              (impl (impl (var "α") (var "β"))
                                    (impl (var "α") (var "γ"))))))

  (define ¬¬-elim (postulate (impl (¬¬ (var "α")) (var "α")))))

;; Γ ⊢ Q ⊃ Γ ⊢ P → Q
(defun →-intro (P T) (mp T (invariance₁ (list "α" (formula T) "β" P) veq)))

(defthm principle-of-explosion (impl ⊥ (var "P"))
  (mp (invariance₁ (list "α" ⊥ "β" (¬ (var "P"))) veq)
      (mp (→-intro ⊥ (invariance₁ (list "α" (var "P")) ¬¬-elim))
          (invariance₁ (list "α" ⊥ "β" (¬¬ (var "P")) "γ" (var "P")) cr))))

(defthm I (impl (var "α") (var "α"))
  (mp (invariance₁ (list "β" (var "α")) veq)
      (mp (invariance₁ (list "β" (impl (var "α") (var "α"))) veq)
          (invariance₁ (list "γ" (var "α") "β" (impl (var "α") (var "α"))) cr))))

;; Γ ⊢ P → Q ⊃ Γ ⊢ P → (P → Q)
(defun dup (T) (→-intro (proj (formula T) 0) T))

;; Γ ⊢ P → (P → Q) ⊃ Γ ⊢ P → Q
(defun pop (T)
  (case (formula T) (impl (var "P") (impl (var "P") (var "Q")))
    (mp (invariance₁ (list "α" P) I)
        (mp T (invariance₁ (list "α" P "β" P "γ" Q) cr)))))

(defthm cut (impl (var "P") (impl (impl (var "P") (var "Q")) (var "Q")))
  (let (T₁ (→-intro (var "P")
             (mp (invariance₁ (list "α" (impl (var "P") (var "Q"))) I)
                 (invariance₁ (list "α" (impl (var "P") (var "Q"))
                                    "β" (var "P")
                                    "γ" (var "Q")) cr)))
        T₂ (invariance₁ (list "α" (var "P")
                              "β" (impl (impl (var "P") (var "Q")) (var "P"))
                              "γ" (impl (impl (var "P") (var "Q")) (var "Q"))) cr)
        T₃ (invariance₁ (list "α" (var "P")
                              "β" (impl (var "P") (var "Q"))) veq))
    (mp T₃ (mp T₁ T₂))))

(defthm ¬¬-intro (impl (var "α") (¬¬ (var "α")))
  (invariance₁ (list "P" (var "α") "Q" ⊥) cut))

(defthm →-comm (impl (impl (var "P") (impl (var "Q") (var "R")))
                     (impl (var "Q") (impl (var "P") (var "R"))))
  (let (T₁ (mp (invariance₁ (list "P" (var "Q") "Q" (var "R")) cut)
               (mp (→-intro (var "Q") (invariance₁ (list "α" (impl (impl (var "Q") (var "R")) (var "R"))
                                                         "β" (var "P")) veq))
                   (invariance₁ (list "α" (var "Q")
                                      "β" (impl (impl (var "Q") (var "R")) (var "R"))
                                      "γ" (impl (var "P") (impl (impl (var "Q") (var "R")) (var "R")))) cr)))
        T₂ (→-intro (var "Q") (invariance₁ (list "α" (var "P")
                                                 "β" (impl (var "Q") (var "R"))
                                                 "γ" (var "R")) cr))
        T₃ (invariance₁ (list "α" (var "Q")
                              "β" (impl (var "P") (impl (impl (var "Q") (var "R")) (var "R")))
                              "γ" (impl (impl (var "P") (impl (var "Q") (var "R"))) (impl (var "P") (var "R")))) cr)
        T₄ (invariance₁ (list "α" (var "Q")
                              "β" (impl (var "P") (impl (var "Q") (var "R")))
                              "γ" (impl (var "P") (var "R"))) cr)
        T₅ (invariance₁ (list "α" (impl (var "P") (impl (var "Q") (var "R")))
                              "β" (impl (var "Q") (impl (var "P") (impl (var "Q") (var "R"))))
                              "γ" (impl (var "Q") (impl (var "P") (var "R")))) cr)
        T₆ (invariance₁ (list "α" (impl (var "P") (impl (var "Q") (var "R")))
                              "β" (var "Q")) veq))
    (mp T₆ (mp (→-intro (impl (var "P") (impl (var "Q") (var "R"))) (mp (mp T₁ (mp T₂ T₃)) T₄)) T₅))))

;; https://en.wikipedia.org/wiki/Hypothetical_syllogism#Proof
(defthm hypsyll (impl (impl (var "Q") (var "R"))
                      (impl (impl (var "P") (var "Q"))
                            (impl (var "P") (var "R"))))
  (let (T₁ (mp (invariance₁ (list "α" (var "P") "β" (var "Q") "γ" (var "R")) cr)
               (invariance₁ (list "α" (impl (impl (var "P") (impl (var "Q") (var "R")))
                                                   (impl (impl (var "P") (var "Q"))
                                                         (impl (var "P") (var "R"))))
                                         "β" (impl (var "Q") (var "R"))) veq))
        T₂ (invariance₁ (list "α" (impl (var "Q") (var "R"))
                              "β" (impl (var "P") (impl (var "Q") (var "R")))
                              "γ" (impl (impl (var "P") (var "Q"))
                                        (impl (var "P") (var "R")))) cr)
        T₃ (invariance₁ (list "α" (impl (var "Q") (var "R"))
                              "β" (var "P")) veq))
    (mp T₃ (mp T₁ T₂))))

;;;;

(defthm test-thm (impl (var "B") (var "B"))
  (invariance₂ "α" "B" I))

(define ∃ (λ (x P) (binder "∃" x P)))

(define τ₀ (∃ "y" (app "Ineq" (list (var "x") (var "y")))))
;(print (subst (list "x" (var "y")) τ₀) "\n") ; will emit an error
(print (subst (list "x" (var "z")) τ₀) "\n")

(print veq " & " (formula veq) "\n")

(print (invariance₁ (list "α" (var "A")) I) "\n")
(print ¬¬-elim "\n")

(let (x 1 y 2) (print (+ x y)) (newline))

(defmacro incr! (x) (semiquote assign! (unquote x) (+ (deref (unquote x)) 1)))

(let (n (ref 0))
  (loop (print (deref n) " ") (incr! n)
        (not (= (deref n) 5))))
(newline)

(define generate-macro (λ (name) (macro (y) (list '+ name y))))

(print "fin")
(newline)