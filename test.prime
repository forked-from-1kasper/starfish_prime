(define cadr   (λ (xs) (car (cdr xs))))
(define cddr   (λ (xs) (cdr (cdr xs))))
(define caddr  (λ (xs) (car (cdr (cdr xs)))))
(define cdddr  (λ (xs) (car (cdr (cdr xs)))))
(define cadddr (λ (xs) (car (cdr (cdr (cdr xs))))))
(define cddddr (λ (xs) (cdr (cdr (cdr (cdr xs))))))

(define defun    (macro σ (list 'define (car σ) (cons 'λ (cons (cadr σ) (cddr σ))))))
(define defmacro (macro σ (list 'define (car σ) (cons 'macro (cons (cadr σ) (cddr σ))))))

(defun idfun (x) x)
(defun const (x y) x)

(defun odd-elements  (xs) (if (= xs nil) nil (cons (car xs)  (odd-elements  (cddr xs)))))
(defun even-elements (xs) (if (= xs nil) nil (cons (cadr xs) (even-elements (cddr xs)))))

(defun semiquote/eager (ε)
  (if (= (typeof ε) 'list)
      (if (= (car ε) 'unquote)
          (if (= (length ε) 2) (cadr ε) (fail "unquote"))
          (cons 'list (mapcar semiquote/eager ε)))
      (list 'quote ε)))

(defmacro semiquote σ (semiquote/eager σ))

(defmacro let σ
  (cons (cons 'λ (cons (odd-elements (car σ)) (cdr σ)))
        (even-elements (car σ))))

(defmacro defthm (name statement proof)
  (list 'progn (list 'define name proof)
    (list 'if (list '= (list 'formula name) statement)
      nil (list 'fail "defthm:" (list 'formula name) "≠" statement))))

(defmacro DICT σ (list 'dict (cons 'list σ)))
(defmacro SET  σ (list 'set  (cons 'list σ)))

;;;;

(define ⊥ (app "false" nil))

(defun ¬    (P) (⊃ P ⊥))
(defun ¬¬   (P) (¬ (¬ P)))
(defun ¬¬¬  (P) (¬ (¬¬ P)))
(defun ¬¬¬¬ (P) (¬ (¬¬¬ P)))

(defun impl (P Q) (app "Impl" (list P Q)))

(define ⊤ (impl ⊥ ⊥))
(defun ⊃ σ (if (= σ nil) ⊤ (foldr impl σ)))

(defun Proj (τ n) (get n (cdr τ)))
(defun Arity (τ) (length (cdr τ)))

(deftheory ZOL ;; zeroth-order logic
  (defun well-formed? σ
    (if (forall (λ (ε) (= (theory ε) "ZOL")) σ) nil
        (fail "expected theorem of zeroth-order logic")))

  (defun invariance (θ T) (well-formed? T)
    (postulate (subst θ (formula T))))

  (defun mp (T₁ T₂) (well-formed? T₁ T₂)
    (case (formula T₁) (var "P")
          (formula T₂) (⊃ (var "P") (var "Q"))
      (postulate Q)))

  (defun veq (α β) (postulate (⊃ α β α)))

  (defun cr (α β γ) (postulate (⊃ (⊃ α β γ) (⊃ α β) (⊃ α γ))))

  (defun ¬¬-elim (α) (postulate (⊃ (¬¬ α) α))))

;; Γ ⊢ Q ⊃ Γ ⊢ P → Q
(defun →-intro (P T) (mp T (veq (formula T) P)))

(defthm principle-of-explosion (⊃ ⊥ (var "P"))
  (mp (veq ⊥ (¬ (var "P")))
      (mp (→-intro ⊥ (¬¬-elim (var "P")))
          (cr ⊥ (¬¬ (var "P")) (var "P")))))

(defthm I (⊃ (var "α") (var "α"))
  (mp (veq (var "α") (var "α"))
      (mp (veq (var "α") (⊃ (var "α") (var "α")))
          (cr (var "α") (⊃ (var "α") (var "α")) (var "α")))))

(defthm truth ⊤ (invariance (DICT "α" ⊥) I))

;; Γ ⊢ P → Q ⊃ Γ ⊢ P → (P → Q)
(defun dup (T) (→-intro (Proj (formula T) 0) T))

;; Γ ⊢ P → (P → Q) ⊃ Γ ⊢ P → Q
(defun pop (T)
  (case (formula T) (⊃ (var "P") (⊃ (var "P") (var "Q")))
    (mp (invariance (DICT "α" P) I) (mp T (cr P P Q)))))

(defthm cut (⊃ (var "P") (⊃ (⊃ (var "P") (var "Q")) (var "Q")))
  (let (T₁ (→-intro (var "P")
             (mp (invariance (DICT "α" (⊃ (var "P") (var "Q"))) I)
                 (cr (⊃ (var "P") (var "Q")) (var "P") (var "Q"))))
        T₂ (cr (var "P")
               (⊃ (⊃ (var "P") (var "Q")) (var "P"))
               (⊃ (⊃ (var "P") (var "Q")) (var "Q")))
        T₃ (veq (var "P") (⊃ (var "P") (var "Q"))))
    (mp T₃ (mp T₁ T₂))))

(defthm ¬¬-intro (⊃ (var "α") (¬¬ (var "α")))
  (invariance (DICT "P" (var "α") "Q" ⊥) cut))

(defthm →-comm (⊃ (⊃ (var "P") (var "Q") (var "R"))
                  (⊃ (var "Q") (var "P") (var "R")))
  (let (T₁ (mp (invariance (DICT "P" (var "Q") "Q" (var "R")) cut)
               (mp (→-intro (var "Q") (veq (⊃ (⊃ (var "Q") (var "R")) (var "R")) (var "P")))
                   (cr (var "Q")
                       (⊃ (⊃ (var "Q") (var "R")) (var "R"))
                       (⊃ (var "P") (⊃ (var "Q") (var "R")) (var "R")))))
        T₂ (→-intro (var "Q") (cr (var "P")
                                  (⊃ (var "Q") (var "R"))
                                  (var "R")))
        T₃ (cr (var "Q")
               (⊃ (var "P") (⊃ (var "Q") (var "R")) (var "R"))
               (⊃ (⊃ (var "P") (var "Q") (var "R")) (var "P") (var "R")))
        T₄ (cr (var "Q")
               (⊃ (var "P") (var "Q") (var "R"))
               (⊃ (var "P") (var "R")))
        T₅ (cr (⊃ (var "P") (var "Q") (var "R"))
               (⊃ (var "Q") (var "P") (var "Q") (var "R"))
               (⊃ (var "Q") (var "P") (var "R")))
        T₆ (veq (⊃ (var "P") (⊃ (var "Q") (var "R")))
                (var "Q")))
    (mp T₆ (mp (→-intro (⊃ (var "P") (var "Q") (var "R")) (mp (mp T₁ (mp T₂ T₃)) T₄)) T₅))))

;; https://en.wikipedia.org/wiki/Hypothetical_syllogism#Proof
(defthm hypsyll (⊃ (⊃ (var "Q") (var "R"))
                   (⊃ (var "P") (var "Q"))
                   (⊃ (var "P") (var "R")))
  (let (T₁ (mp (cr (var "P") (var "Q") (var "R"))
               (veq (⊃ (⊃ (var "P") (var "Q") (var "R"))
                       (⊃ (var "P") (var "Q"))
                       (⊃ (var "P") (var "R")))
                    (⊃ (var "Q") (var "R"))))
        T₂ (cr (⊃ (var "Q") (var "R"))
               (⊃ (var "P") (var "Q") (var "R"))
               (⊃ (⊃ (var "P") (var "Q"))
                  (⊃ (var "P") (var "R"))))
        T₃ (veq (⊃ (var "Q") (var "R")) (var "P")))
    (mp T₃ (mp T₁ T₂))))

;;;;

(defthm test-thm (⊃ (var "B") (var "B"))
  (invariance (DICT "α" (var "B")) I))

(define ∃ (λ (x P) (binder "∃" x P)))

(define τ₀ (∃ "y" (app "Ineq" (list (var "x") (var "y")))))
(print (subst (DICT "x" (var "y")) τ₀) "\n") ; “y” is already captured, so it’s safe to have it in substitution
(print (subst (DICT "x" (var "z")) τ₀) "\n")
(print (free (app "T" nil) τ₀) "\n")
(print τ₀ " & " (rebind "∀" τ₀) "\n")

(let (φ (veq (var "A") (var "B")))
  (print φ " & " (formula φ) "\n"))

(let (ψ (cr (var "A") (var "B") (var "C")))
  (print ψ " & " (dup ψ) "\n"))

(print (invariance (DICT "α" (var "A")) I) "\n")
(print (¬¬-elim (var "P")) "\n")

(let (x 1 y 2) (print (+ x y)) (newline))

(defmacro incr! (x) (semiquote assign! (unquote x) (+ (deref (unquote x)) 1)))

(let (n (ref 0))
  (loop (print (deref n) " ") (incr! n)
        (not (= (deref n) 5))))
(newline)

(define generate-macro (λ (name) (macro (y) (list '+ name y))))

(print "fin")
(newline)