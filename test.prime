(define "def" (macro (e₁ e₂) (list 'define (show e₁) e₂)))

(def cadr   (λ (xs) (car (cdr xs))))
(def cddr   (λ (xs) (cdr (cdr xs))))
(def caddr  (λ (xs) (car (cdr (cdr xs)))))
(def cdddr  (λ (xs) (car (cdr (cdr xs)))))
(def cadddr (λ (xs) (car (cdr (cdr (cdr xs))))))
(def cddddr (λ (xs) (cdr (cdr (cdr (cdr xs))))))

(def defun    (macro σ (list 'define (show (car σ)) (cons 'λ (cons (cadr σ) (cddr σ))))))
(def defmacro (macro σ (list 'define (show (car σ)) (cons 'macro (cons (cadr σ) (cddr σ))))))

(defun idfun (x) x)
(defun const (x y) x)

(defun odd-elements  (xs) (if (= xs nil) nil (cons (car xs)  (odd-elements  (cddr xs)))))
(defun even-elements (xs) (if (= xs nil) nil (cons (cadr xs) (even-elements (cddr xs)))))

(defun semiquote/eager (ε)
  (if (= (typeof ε) 'list)
      (if (= (car ε) 'unquote)
          (if (= (length ε) 2) (cadr ε) (fail "unquote"))
          (cons 'list (mapcar semiquote/eager ε)))
      (list 'quote ε)))

(defmacro semiquote σ (semiquote/eager σ))

(defmacro DICT σ (list 'dict (cons 'list σ)))
(defmacro SET  σ (list 'set  (cons 'list σ)))

(defmacro let σ
  (cons (cons 'λ (cons (odd-elements (car σ)) (cdr σ)))
        (even-elements (car σ))))

(defmacro defthm (name statement proof)
  (list 'progn (list 'def name proof)
    (list 'if (list '= (list 'formula name) statement)
      nil (list 'fail "defthm:" (list 'formula name) "≠" statement))))

(defmacro variables σ (cons 'progn (mapcar (λ (ε) (list 'def ε (list 'var (show ε)))) σ)))

;;;;

(def ⊥ (app "false" nil))

(defun ¬    (P) (⊃ P ⊥))
(defun ¬¬   (P) (¬ (¬ P)))
(defun ¬¬¬  (P) (¬ (¬¬ P)))
(defun ¬¬¬¬ (P) (¬ (¬¬¬ P)))

(defun impl (P Q) (app "Impl" (list P Q)))

(def ⊤ (impl ⊥ ⊥))
(defun ⊃ σ (if (= σ nil) ⊤ (foldr impl σ)))

(defun Proj (τ n) (get n (cdr τ)))
(defun Arity (τ) (length (cdr τ)))

(defun assert-subset (A B F) (each (λ (a) (if (mem a B) true (F a))) A))

(deftheory ZOL ;; zeroth-order logic
  (defun well-formed? σ
    (if (forall (λ (ε) (= (theory ε) "ZOL")) σ) nil
        (fail "expected theorem of zeroth-order logic")))

  (let (E (ref (SET "Impl" "false")))
    (defun define-term (φ σ τ)
      (if (not (= (typeof τ) 'formula))
          (fail "expected formula of zeroth-order logic"))

      (if (mem φ (deref E)) (fail φ "is already declared"))

      (assert-subset (fv τ)  (set σ)   (λ (x) (fail "unknown variable" x)))
      (assert-subset (Fun τ) (deref E) (λ (x) (fail "unknown functional symbol" x)))

      (assign! E (add φ (deref E)))

      (define φ (if (= (length σ) 0) (app φ nil) (λ σ′ (app φ σ′))))

      (let (R (app φ (mapcar var σ)))
        (define (+ φ "-intro") (postulate (⊃ τ R)))
        (define (+ φ "-elim")  (postulate (⊃ R τ))))))

  (defun invariance (θ T) (well-formed? T)
    (postulate (subst θ (formula T))))

  (defun mp (T₁ T₂) (well-formed? T₁ T₂)
    (case (formula T₁) (var "P")
          (formula T₂) (⊃ (var "P") (var "Q"))
      (postulate Q)))

  (defun veq (α β) (postulate (⊃ α β α)))

  (defun cr (α β γ) (postulate (⊃ (⊃ α β γ) (⊃ α β) (⊃ α γ))))

  (defun ¬¬-elim (α) (postulate (⊃ (¬¬ α) α))))

(defmacro defterm σ
  (let (φ (car σ) Π (mapcar show (cadr σ)))
    (let (ε (cons (cons 'lambda (cdr σ)) (mapcar var Π)))
      (list 'define-term (show φ) (cons 'list Π) ε))))

(defterm Or  (P Q) (⊃ (¬ P) Q))
(defterm And (P Q) (¬ (⊃ P (¬ Q))))
(defterm Iff (P Q) (And (⊃ P Q) (⊃ Q P)))

(defun ∨ σ (foldr Or  σ))
(defun ∧ σ (foldr And σ))
(def ↔ Iff)

;; Γ ⊢ Q ⊃ Γ ⊢ P → Q
(defun →-intro (P T) (mp T (veq (formula T) P)))

(variables P Q R α β γ)

(defthm principle-of-explosion (⊃ ⊥ P)
  (mp (veq ⊥ (¬ P))
      (mp (→-intro ⊥ (¬¬-elim P))
          (cr ⊥ (¬¬ P) P))))

(defthm I (⊃ α α)
  (mp (veq α α)
      (mp (veq α (⊃ α α))
          (cr α (⊃ α α) α))))

(defthm truth ⊤ (invariance (DICT "α" ⊥) I))

;; Γ ⊢ P → Q ⊃ Γ ⊢ P → (P → Q)
(defun dup (T) (→-intro (Proj (formula T) 0) T))

;; Γ ⊢ P → (P → Q) ⊃ Γ ⊢ P → Q
(defun pop (T)
  (case (formula T) (⊃ P (⊃ P Q))
    (mp (invariance (DICT "α" P) I) (mp T (cr P P Q)))))

(defthm cut (⊃ P (⊃ P Q) Q)
  (let (T₁ (→-intro P
             (mp (invariance (DICT "α" (⊃ P Q)) I)
                 (cr (⊃ P Q) P Q)))
        T₂ (cr P
               (⊃ (⊃ P Q) P)
               (⊃ (⊃ P Q) Q))
        T₃ (veq P (⊃ P Q)))
    (mp T₃ (mp T₁ T₂))))

;; Γ ⊢ P → ¬¬P
(defun ¬¬-intro (α) (invariance (DICT "P" α "Q" ⊥) cut))

(defthm →-comm (⊃ (⊃ P Q R) (⊃ Q P R))
  (let (T₁ (mp (invariance (DICT "P" Q "Q" R) cut)
               (mp (→-intro Q (veq (⊃ (⊃ Q R) R) P))
                   (cr Q (⊃ (⊃ Q R) R) (⊃ P (⊃ Q R) R))))
        T₂ (→-intro Q (cr P (⊃ Q R) R))
        T₃ (cr Q (⊃ P (⊃ Q R) R) (⊃ (⊃ P Q R) P R))
        T₄ (cr Q (⊃ P Q R) (⊃ P R))
        T₅ (cr (⊃ P Q R) (⊃ Q P Q R) (⊃ Q P R))
        T₆ (veq (⊃ P (⊃ Q R)) Q))
    (mp T₆ (mp (→-intro (⊃ P Q R) (mp (mp T₁ (mp T₂ T₃)) T₄)) T₅))))

;; Γ ⊢ P → Q → R ⊃ Γ ⊢ Q → P → R
(defun flip (T)
  (case (formula T) (⊃ P Q R)
    (mp T (invariance (DICT "P" P "Q" Q "R" R) →-comm))))

;; https://en.wikipedia.org/wiki/Hypothetical_syllogism#Proof
(defthm hypsyll₁ (⊃ (⊃ Q R) (⊃ P Q) (⊃ P R))
  (let (T₁ (mp (cr P Q R)
               (veq (⊃ (⊃ P Q R) (⊃ P Q) (⊃ P R))
                    (⊃ Q R)))
        T₂ (cr (⊃ Q R)
               (⊃ P Q R)
               (⊃ (⊃ P Q) (⊃ P R)))
        T₃ (veq (⊃ Q R) P))
    (mp T₃ (mp T₁ T₂))))

(defthm hypsyll₂ (⊃ (⊃ P Q) (⊃ Q R) (⊃ P R)) (flip hypsyll₁))

(defun →-trans σ
  (let (φ (λ (T₁ T₂) (case (formula T₁) (⊃ P Q) (formula T₂) (⊃ Q R)
            (mp T₁ (mp T₂ (invariance (DICT "P" P "Q" Q "R" R) hypsyll₁))))))
    (foldr φ σ)))

;; Γ ⊢ Q → R ⊃ Γ ⊢ (P → Q) → (P → R)
(defun →-ant (P T) (case (formula T) (⊃ Q R) (mp T (invariance (DICT "P" P "Q" Q "R" R) hypsyll₁))))

;; Γ ⊢ P → Q ⊃ Γ ⊢ (Q → R) → (P → R)
(defun →-con (R T) (case (formula T) (⊃ P Q) (mp T (invariance (DICT "P" P "Q" Q "R" R) hypsyll₂))))

(defun exact (φ T) (invariance (unify (formula T) φ) T))

(def contrapos₁ (exact (⊃ (⊃ P Q) (⊃ (¬ Q) (¬ P))) hypsyll₂))

(defthm contrapos₂ (⊃ (⊃ (¬ Q) (¬ P)) (⊃ P Q))
  (→-trans (invariance (DICT "P" (¬ Q) "Q" (¬ P)) contrapos₁)
           (→-con (¬¬ Q) (¬¬-intro P))
           (→-ant P (¬¬-elim Q))))

(defthm contrapos₃ (⊃ (⊃ P (¬ Q)) (⊃ Q (¬ P)))
  (→-trans (invariance (DICT "P" P "Q" (¬ Q)) contrapos₁)
           (→-con (¬ P) (¬¬-intro Q))))

(defthm contrapos₄ (⊃ (⊃ (¬ P) Q) (⊃ (¬ Q) P))
  (→-trans (invariance (DICT "P" (¬ P) "Q" Q) contrapos₁)
           (→-ant (¬ Q) (¬¬-elim P))))

(defthm absurd₁ (⊃ (¬ P) P Q)
  (→-ant P (invariance (DICT "P" Q) principle-of-explosion)))

(defthm absurd₂ (⊃ P (¬ P) Q) (flip absurd₁))

(defthm ∧-left (⊃ (∧ P Q) P)
  (→-trans And-elim (mp (invariance (DICT "P" P "Q" (¬ Q)) absurd₁)
                        (invariance (DICT "P" P "Q" (⊃ P (¬ Q))) contrapos₄))))

(defthm ∧-right (⊃ (∧ P Q) Q)
  (→-trans And-elim (mp (veq (¬ Q) P) (invariance (DICT "P" Q "Q" (⊃ P (¬ Q))) contrapos₄))))

(defthm ∧-intro (⊃ P Q (∧ P Q))
  (mp (invariance (DICT "P" P "Q" (¬ Q)) cut)
      (→-ant P (→-trans (invariance (DICT "P" (⊃ P (¬ Q)) "Q" Q) contrapos₃)
                        (→-ant Q And-intro)))))

;;;;

(defthm test-thm (⊃ (var "B") (var "B"))
  (invariance (DICT "α" (var "B")) I))

(def ∃ (λ (x P) (binder "∃" x P)))

(def τ₀ (∃ "y" (app "Ineq" (list (var "x") (var "y")))))
(print (subst (DICT "x" (var "y")) τ₀) "\n") ; “y” is already captured, so it’s safe to have it in substitution
(print (subst (DICT "x" (var "z")) τ₀) "\n")
(print (free (app "T" nil) τ₀) "\n")
(print τ₀ " & " (rebind "∀" τ₀) "\n")

(let (φ (veq (var "A") (var "B")))
  (print φ " & " (formula φ) "\n"))

(let (ψ (cr (var "A") (var "B") (var "C")))
  (print ψ " & " (dup ψ) "\n"))

(print (invariance (DICT "α" (var "A")) I) "\n")
(print (¬¬-elim P) "\n")

(let (x 1 y 2) (print (+ x y)) (newline))

(defmacro incr! (x) (semiquote assign! (unquote x) (+ (deref (unquote x)) 1)))

(let (n (ref 0))
  (loop (print (deref n) " ") (incr! n)
        (not (= (deref n) 5))))
(newline)

(def generate-macro (λ (name) (macro (y) (list '+ name y))))

(print "fin")
(newline)