(define cadr   (lambda (xs) (car (cdr xs))))
(define cddr   (lambda (xs) (cdr (cdr xs))))
(define caddr  (lambda (xs) (car (cdr (cdr xs)))))
(define cdddr  (lambda (xs) (car (cdr (cdr xs)))))
(define cadddr (lambda (xs) (car (cdr (cdr (cdr xs))))))
(define cddddr (lambda (xs) (cdr (cdr (cdr (cdr xs))))))

(define defun    (macro exprs (list 'define (car exprs) (cons 'lambda (cons (cadr exprs) (cddr exprs))))))
(define defmacro (macro exprs (list 'define (car exprs) (cons 'macro  (cons (cadr exprs) (cddr exprs))))))

(defun idfun (x) x)
(defun const (x y) x)

(defun odd-elements  (xs) (if (= xs nil) nil (cons (car xs)  (odd-elements  (cddr xs)))))
(defun even-elements (xs) (if (= xs nil) nil (cons (cadr xs) (even-elements (cddr xs)))))

(defun mapcar (φ xs) (if (= xs nil) nil (cons (φ (car xs)) (mapcar φ (cdr xs)))))

(defun semiquote/eager (ε)
  (if (= (typeof ε) 'list)
      (if (= (car ε) 'unquote)
          (if (= (length ε) 2) (cadr ε) (fail "unquote"))
          (cons 'list (mapcar semiquote/eager ε)))
      (list 'quote ε)))

(defmacro semiquote σ (semiquote/eager σ))

(defmacro let σ
  (cons (cons 'lambda (cons (odd-elements (car σ)) (cdr σ)))
        (even-elements (car σ))))

(defmacro defthm (name statement proof)
  (list 'progn (list 'define name proof)
    (list 'if (list '= (list 'formula name) statement)
      nil (list 'fail "defthm:" (list 'formula name) "≠" statement))))

;;;;

(define ⊥ (app "false" nil))

(defun impl (P Q) (app "Impl" (list P Q)))

(defun ¬ (P) (impl P ⊥))
(defun ¬¬ (P) (¬ (¬ P)))

(define ⊤ (¬ ⊥))

(defun proj (τ n) (nth n (cdr τ)))
(defun arity (τ) (length (cdr τ)))

(deftheory ZOL ;; zeroth-order logic
  (defmacro well-founded? σ
    (list 'if (cons 'and (mapcar (lambda (ε) (list '= (list 'theory ε) "ZOL")) σ)) nil
      (list 'fail "expected formula of zeroth-order logic")))

  (defun invariance₁ (θ T)   (well-founded? T) (postulate (subst θ (formula T))))
  (defun invariance₂ (x y T) (well-founded? T) (postulate (interchange x y (formula T))))

  (defun mp (T₁ T₂) (well-founded? T₁ T₂)
    (case (formula T₁) (var "P")
          (formula T₂) (impl (var "P") (var "Q"))
      (postulate Q)))

  (define veq (postulate (impl (var "α") (impl (var "β") (var "α")))))

  (define cr (postulate (impl (impl (var "α") (impl (var "β") (var "γ")))
                              (impl (impl (var "α") (var "β"))
                                    (impl (var "α") (var "γ"))))))

  (define double-negation (postulate (impl (¬¬ (var "α")) (var "α")))))

(defthm I (impl (var "α") (var "α"))
  (mp (invariance₁ (list "β" (var "α")) veq)
    (mp (invariance₁ (list "β" (impl (var "α") (var "α"))) veq)
        (invariance₁ (list "γ" (var "α") "β" (impl (var "α") (var "α"))) cr))))

;; Γ ⊢ Q ⊃ Γ ⊢ P → Q
(defun →-intro (P T) (mp T (invariance₁ (list "α" (formula T) "β" P) veq)))

(defthm principle-of-explosion (impl ⊥ (var "P"))
  (mp (invariance₁ (list "α" ⊥ "β" (¬ (var "P"))) veq)
      (mp (→-intro ⊥ (invariance₁ (list "α" (var "P")) double-negation))
          (invariance₁ (list "α" ⊥ "β" (¬¬ (var "P")) "γ" (var "P")) cr))))

(defthm test-thm (impl (var "B") (var "B"))
  (invariance₁ (list "α" (var "B")) I))

;;;;

(define ∃ (lambda (x P) (binder "∃" x P)))

(define τ₀ (∃ "y" (app "Ineq" (list (var "x") (var "y")))))
;(print (subst (list "x" (var "y")) τ₀) "\n") ; will emit an error
(print (subst (list "x" (var "z")) τ₀) "\n")

(print veq " & " (formula veq) "\n")

(print (invariance₁ (list "α" (var "A")) I) "\n")
(print double-negation "\n")

(let (x 1 y 2) (print (+ x y)) (newline))

(defmacro incr! (x) (semiquote assign! (unquote x) (+ (deref (unquote x)) 1)))

(let (n (ref 0))
  (loop (print (deref n) " ") (incr! n)
        (not (= (deref n) 5))))
(newline)

(define generate-macro (lambda (name) (macro (y) (list '+ name y))))

(print "fin")
(newline)